# Internationalization (i18n) Module

Локалізація та багатомовність платформи.

## Огляд

| Властивість | Значення |
|-------------|----------|
| Мови за замовчуванням | UK, EN, RU |
| Формат файлів | JSON |
| Fallback | uk → en |

## Архітектура

```
┌─────────────────────────────────────────────────────────────────┐
│                       I18N MODULE                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                  Translation Layer                       │   │
│  │                                                          │   │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────────────────┐  │   │
│  │  │ Backend  │  │ Frontend │  │    Database          │  │   │
│  │  │  (Go)    │  │ (Next.js)│  │  (PostgreSQL)        │  │   │
│  │  └────┬─────┘  └────┬─────┘  └──────────┬───────────┘  │   │
│  │       │             │                    │              │   │
│  │       ▼             ▼                    ▼              │   │
│  │  ┌──────────────────────────────────────────────────┐  │   │
│  │  │              Translation Files                    │  │   │
│  │  │                                                   │  │   │
│  │  │  locales/                                         │  │   │
│  │  │  ├── uk/                                          │  │   │
│  │  │  │   ├── common.json                              │  │   │
│  │  │  │   ├── products.json                            │  │   │
│  │  │  │   └── checkout.json                            │  │   │
│  │  │  ├── en/                                          │  │   │
│  │  │  └── ru/                                          │  │   │
│  │  └──────────────────────────────────────────────────┘  │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                  Locale Detection                        │   │
│  │                                                          │   │
│  │  URL Path → Header → Cookie → Browser → Default         │   │
│  │                                                          │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

## Підтримувані мови

| Код | Мова | Напрямок |
|-----|------|----------|
| `uk` | Українська | LTR |
| `en` | English | LTR |
| `ru` | Русский | LTR |
| `pl` | Polski | LTR |
| `de` | Deutsch | LTR |

## Структура файлів перекладів

```
locales/
├── uk/
│   ├── common.json
│   ├── navigation.json
│   ├── products.json
│   ├── checkout.json
│   ├── orders.json
│   ├── auth.json
│   ├── errors.json
│   └── emails.json
├── en/
│   ├── common.json
│   ├── navigation.json
│   └── ...
└── ru/
    └── ...
```

## Формат перекладів

### common.json

```json
{
  "app": {
    "name": "Магазин",
    "tagline": "Найкращі товари за найкращими цінами"
  },
  "actions": {
    "save": "Зберегти",
    "cancel": "Скасувати",
    "delete": "Видалити",
    "edit": "Редагувати",
    "add": "Додати",
    "search": "Пошук",
    "filter": "Фільтр",
    "sort": "Сортування",
    "apply": "Застосувати",
    "reset": "Скинути",
    "back": "Назад",
    "next": "Далі",
    "confirm": "Підтвердити"
  },
  "status": {
    "loading": "Завантаження...",
    "error": "Помилка",
    "success": "Успішно",
    "noResults": "Нічого не знайдено"
  },
  "pagination": {
    "page": "Сторінка {{current}} з {{total}}",
    "showing": "Показано {{from}}-{{to}} з {{total}}",
    "itemsPerPage": "Елементів на сторінці"
  }
}
```

### products.json

```json
{
  "product": {
    "title": "Товар",
    "price": "Ціна",
    "description": "Опис",
    "sku": "Артикул",
    "inStock": "В наявності",
    "outOfStock": "Немає в наявності",
    "addToCart": "Додати в кошик",
    "buyNow": "Купити зараз",
    "quantity": "Кількість",
    "reviews": "{{count}} відгуків",
    "rating": "Рейтинг: {{value}} з 5"
  },
  "catalog": {
    "title": "Каталог",
    "categories": "Категорії",
    "filters": "Фільтри",
    "priceRange": "Діапазон цін",
    "brand": "Бренд",
    "sortBy": {
      "label": "Сортувати за",
      "popular": "Популярністю",
      "newest": "Новизною",
      "priceAsc": "Ціною (від низької)",
      "priceDesc": "Ціною (від високої)",
      "rating": "Рейтингом"
    }
  },
  "stockStatus": {
    "available": "Є в наявності ({{count}} шт.)",
    "limited": "Залишилось {{count}} шт.",
    "outOfStock": "Немає в наявності",
    "preorder": "Під замовлення"
  }
}
```

### checkout.json

```json
{
  "cart": {
    "title": "Кошик",
    "empty": "Ваш кошик порожній",
    "items": "{{count}} товарів",
    "subtotal": "Сума",
    "shipping": "Доставка",
    "discount": "Знижка",
    "total": "Всього",
    "proceedToCheckout": "Оформити замовлення",
    "continueShopping": "Продовжити покупки"
  },
  "checkout": {
    "title": "Оформлення замовлення",
    "steps": {
      "contact": "Контактні дані",
      "shipping": "Доставка",
      "payment": "Оплата",
      "confirmation": "Підтвердження"
    },
    "contact": {
      "firstName": "Ім'я",
      "lastName": "Прізвище",
      "email": "Email",
      "phone": "Телефон"
    },
    "shipping": {
      "method": "Спосіб доставки",
      "address": "Адреса",
      "city": "Місто",
      "warehouse": "Відділення"
    },
    "payment": {
      "method": "Спосіб оплати",
      "card": "Банківська картка",
      "cash": "Готівкою при отриманні",
      "invoice": "Рахунок-фактура"
    },
    "placeOrder": "Підтвердити замовлення"
  },
  "order": {
    "success": "Замовлення успішно оформлено!",
    "number": "Номер замовлення: {{number}}",
    "thankYou": "Дякуємо за покупку!"
  }
}
```

### errors.json

```json
{
  "validation": {
    "required": "Це поле обов'язкове",
    "email": "Введіть коректний email",
    "phone": "Введіть коректний номер телефону",
    "minLength": "Мінімум {{min}} символів",
    "maxLength": "Максимум {{max}} символів",
    "passwordMismatch": "Паролі не співпадають",
    "invalidFormat": "Невірний формат"
  },
  "api": {
    "networkError": "Помилка з'єднання. Перевірте інтернет",
    "serverError": "Помилка сервера. Спробуйте пізніше",
    "unauthorized": "Необхідно авторизуватися",
    "forbidden": "Доступ заборонено",
    "notFound": "Сторінку не знайдено",
    "timeout": "Час очікування вичерпано"
  },
  "auth": {
    "invalidCredentials": "Невірний email або пароль",
    "emailExists": "Цей email вже зареєстрований",
    "weakPassword": "Пароль занадто простий",
    "sessionExpired": "Сесія закінчилась. Увійдіть знову"
  },
  "cart": {
    "outOfStock": "Товару немає в наявності",
    "maxQuantity": "Максимальна кількість: {{max}}",
    "minOrder": "Мінімальна сума замовлення: {{amount}}"
  }
}
```

## Backend (Go)

### Реалізація

```go
package i18n

import (
    "encoding/json"
    "fmt"
    "os"
    "path/filepath"
    "strings"
    "sync"
)

type Translator struct {
    translations map[string]map[string]any // locale -> namespace -> translations
    fallback     string
    mu           sync.RWMutex
}

func NewTranslator(localesDir string, fallback string) (*Translator, error) {
    t := &Translator{
        translations: make(map[string]map[string]any),
        fallback:     fallback,
    }

    // Завантажуємо всі переклади
    locales, _ := os.ReadDir(localesDir)
    for _, locale := range locales {
        if !locale.IsDir() {
            continue
        }

        localeName := locale.Name()
        t.translations[localeName] = make(map[string]any)

        files, _ := filepath.Glob(filepath.Join(localesDir, localeName, "*.json"))
        for _, file := range files {
            namespace := strings.TrimSuffix(filepath.Base(file), ".json")

            data, _ := os.ReadFile(file)
            var translations map[string]any
            json.Unmarshal(data, &translations)

            t.translations[localeName][namespace] = translations
        }
    }

    return t, nil
}

func (t *Translator) T(locale, key string, params ...map[string]any) string {
    t.mu.RLock()
    defer t.mu.RUnlock()

    // Parse key: "namespace:path.to.key" or "path.to.key" (default: common)
    namespace := "common"
    path := key

    if idx := strings.Index(key, ":"); idx != -1 {
        namespace = key[:idx]
        path = key[idx+1:]
    }

    // Try requested locale, then fallback
    for _, loc := range []string{locale, t.fallback} {
        if ns, ok := t.translations[loc][namespace]; ok {
            if value := getNestedValue(ns.(map[string]any), path); value != "" {
                return interpolate(value, params...)
            }
        }
    }

    return key // Return key if no translation found
}

func getNestedValue(m map[string]any, path string) string {
    keys := strings.Split(path, ".")
    current := m

    for i, key := range keys {
        if val, ok := current[key]; ok {
            if i == len(keys)-1 {
                if str, ok := val.(string); ok {
                    return str
                }
            } else if nested, ok := val.(map[string]any); ok {
                current = nested
            }
        }
    }

    return ""
}

func interpolate(template string, params ...map[string]any) string {
    if len(params) == 0 {
        return template
    }

    result := template
    for key, value := range params[0] {
        placeholder := "{{" + key + "}}"
        result = strings.ReplaceAll(result, placeholder, fmt.Sprintf("%v", value))
    }

    return result
}

// Middleware
func LocaleMiddleware(translator *Translator, supportedLocales []string, defaultLocale string) gin.HandlerFunc {
    return func(c *gin.Context) {
        locale := detectLocale(c, supportedLocales, defaultLocale)
        c.Set("locale", locale)
        c.Set("translator", translator)
        c.Next()
    }
}

func detectLocale(c *gin.Context, supported []string, defaultLocale string) string {
    // 1. URL path (/uk/products)
    if path := c.Param("locale"); contains(supported, path) {
        return path
    }

    // 2. Query param (?lang=uk)
    if lang := c.Query("lang"); contains(supported, lang) {
        return lang
    }

    // 3. Cookie
    if cookie, _ := c.Cookie("locale"); contains(supported, cookie) {
        return cookie
    }

    // 4. Accept-Language header
    acceptLang := c.GetHeader("Accept-Language")
    for _, lang := range parseAcceptLanguage(acceptLang) {
        if contains(supported, lang) {
            return lang
        }
    }

    return defaultLocale
}
```

### Використання в API

```go
func GetProductHandler(c *gin.Context) {
    locale := c.GetString("locale")
    translator := c.MustGet("translator").(*i18n.Translator)

    product, _ := productService.GetByID(c, c.Param("id"))

    // Переклад повідомлень
    response := gin.H{
        "product": product,
        "messages": gin.H{
            "addToCart": translator.T(locale, "products:product.addToCart"),
            "inStock":   translator.T(locale, "products:stockStatus.available", map[string]any{"count": product.Stock}),
        },
    }

    c.JSON(200, response)
}
```

## Frontend (Next.js)

### next-intl / react-intl

```typescript
// i18n/config.ts
export const locales = ['uk', 'en', 'ru'] as const;
export type Locale = typeof locales[number];
export const defaultLocale: Locale = 'uk';

// Mapping to human-readable names
export const localeNames: Record<Locale, string> = {
  uk: 'Українська',
  en: 'English',
  ru: 'Русский',
};
```

### Middleware (app/middleware.ts)

```typescript
import createMiddleware from 'next-intl/middleware';
import { locales, defaultLocale } from './i18n/config';

export default createMiddleware({
  locales,
  defaultLocale,
  localePrefix: 'as-needed', // Only show prefix for non-default locale
});

export const config = {
  matcher: ['/((?!api|_next|.*\\..*).*)'],
};
```

### Використання в компонентах

```tsx
// app/[locale]/products/page.tsx
import { useTranslations } from 'next-intl';

export default function ProductsPage() {
  const t = useTranslations('products');

  return (
    <div>
      <h1>{t('catalog.title')}</h1>

      <select>
        <option>{t('catalog.sortBy.popular')}</option>
        <option>{t('catalog.sortBy.newest')}</option>
        <option>{t('catalog.sortBy.priceAsc')}</option>
      </select>

      {/* With interpolation */}
      <p>{t('product.reviews', { count: 42 })}</p>
    </div>
  );
}
```

### Language Switcher

```tsx
// components/LanguageSwitcher.tsx
'use client';

import { useLocale } from 'next-intl';
import { useRouter, usePathname } from 'next/navigation';
import { locales, localeNames } from '@/i18n/config';

export function LanguageSwitcher() {
  const locale = useLocale();
  const router = useRouter();
  const pathname = usePathname();

  const switchLocale = (newLocale: string) => {
    // Remove current locale from pathname
    const pathWithoutLocale = pathname.replace(`/${locale}`, '') || '/';
    router.push(`/${newLocale}${pathWithoutLocale}`);
  };

  return (
    <select value={locale} onChange={(e) => switchLocale(e.target.value)}>
      {locales.map((loc) => (
        <option key={loc} value={loc}>
          {localeNames[loc]}
        </option>
      ))}
    </select>
  );
}
```

## Database Translations

### Product Translations Table

```sql
CREATE TABLE product_translations (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    product_id UUID NOT NULL REFERENCES products(id) ON DELETE CASCADE,
    locale VARCHAR(5) NOT NULL,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    short_description TEXT,
    meta_title VARCHAR(255),
    meta_description TEXT,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    UNIQUE(product_id, locale)
);

CREATE INDEX idx_product_translations_product_locale
ON product_translations(product_id, locale);
```

### Query with Translations

```go
func (r *ProductRepository) GetWithTranslation(ctx context.Context, id string, locale string) (*Product, error) {
    var product Product

    err := r.db.Raw(`
        SELECT
            p.*,
            COALESCE(t.name, p.name) as name,
            COALESCE(t.description, p.description) as description,
            COALESCE(t.meta_title, p.name) as meta_title,
            COALESCE(t.meta_description, p.description) as meta_description
        FROM products p
        LEFT JOIN product_translations t ON t.product_id = p.id AND t.locale = ?
        WHERE p.id = ?
    `, locale, id).Scan(&product).Error

    return &product, err
}
```

## Pluralization

### Правила для української

```go
func ukrainianPlural(n int) string {
    if n%10 == 1 && n%100 != 11 {
        return "one"   // 1, 21, 31, ...
    }
    if n%10 >= 2 && n%10 <= 4 && (n%100 < 10 || n%100 >= 20) {
        return "few"   // 2, 3, 4, 22, 23, 24, ...
    }
    return "many"      // 0, 5, 6, ..., 11, 12, ...
}

// В JSON:
// "items": {
//   "one": "{{count}} товар",
//   "few": "{{count}} товари",
//   "many": "{{count}} товарів"
// }
```

### Використання

```go
func (t *Translator) Plural(locale, key string, count int, params map[string]any) string {
    form := getPluralForm(locale, count)
    fullKey := key + "." + form

    if params == nil {
        params = make(map[string]any)
    }
    params["count"] = count

    return t.T(locale, fullKey, params)
}
```

## Date/Time Formatting

```go
var dateFormats = map[string]string{
    "uk": "02.01.2006",
    "en": "Jan 2, 2006",
    "ru": "02.01.2006",
}

var timeFormats = map[string]string{
    "uk": "15:04",
    "en": "3:04 PM",
    "ru": "15:04",
}

func FormatDate(t time.Time, locale string) string {
    format := dateFormats[locale]
    if format == "" {
        format = dateFormats["en"]
    }
    return t.Format(format)
}

// Relative time
func FormatRelative(t time.Time, locale string, translator *Translator) string {
    diff := time.Since(t)

    if diff < time.Minute {
        return translator.T(locale, "time:justNow")
    }
    if diff < time.Hour {
        mins := int(diff.Minutes())
        return translator.Plural(locale, "time:minutesAgo", mins, nil)
    }
    // ...
}
```

## Currency Formatting

```go
var currencyFormats = map[string]CurrencyFormat{
    "uk": {Symbol: "₴", Position: "after", DecimalSep: ",", ThousandSep: " "},
    "en": {Symbol: "$", Position: "before", DecimalSep: ".", ThousandSep: ","},
    "ru": {Symbol: "₽", Position: "after", DecimalSep: ",", ThousandSep: " "},
}

func FormatCurrency(amount float64, currency string, locale string) string {
    format := currencyFormats[locale]

    // Format number
    formatted := formatNumber(amount, format.DecimalSep, format.ThousandSep)

    // Add currency symbol
    if format.Position == "before" {
        return format.Symbol + formatted
    }
    return formatted + " " + format.Symbol
}

// 1500.50 + "uk" => "1 500,50 ₴"
// 1500.50 + "en" => "$1,500.50"
```

## API Endpoints

### Get Available Locales

```
GET /api/v1/locales

Response:
{
  "locales": [
    {"code": "uk", "name": "Українська", "default": true},
    {"code": "en", "name": "English"},
    {"code": "ru", "name": "Русский"}
  ]
}
```

### Get Translations

```
GET /api/v1/translations/{locale}/{namespace}

Response:
{
  "locale": "uk",
  "namespace": "products",
  "translations": {
    "product": {
      "title": "Товар",
      "price": "Ціна"
    }
  }
}
```

## Конфігурація

```bash
# Localization
DEFAULT_LOCALE=uk
SUPPORTED_LOCALES=uk,en,ru
LOCALES_PATH=/app/locales
FALLBACK_LOCALE=uk

# Date/Time
DEFAULT_TIMEZONE=Europe/Kiev
DATE_FORMAT=02.01.2006
TIME_FORMAT=15:04

# Currency
DEFAULT_CURRENCY=UAH
CURRENCY_DECIMAL_PLACES=2
```
